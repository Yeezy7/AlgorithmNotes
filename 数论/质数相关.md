# 1. 基础概念

**质数**（又称素数）是指大于 1 的自然数，且除了 1 和它自身外，无法被其他正整数整除的数。

- 最小质数：2（唯一的偶质数）；
- 非质数：1（既不是质数也不是合数）、4（2×2）、6（2×3）等合数。
- 核心性质：若 n 是合数，则 n 必有一个不大于√n 的质因数（为后续算法优化提供依据）。

# 2. 判断单个数字是否为质数

判断一个数`n`是否为质数，需围绕 “排除合数” 设计逻辑，从暴力法逐步优化效率。

## 2.1 暴力枚举法

**原理**

遍历从 `2` 到`n-1`的所有整数，若存在能整除`n`的数，则`n`是合数；否则是质数。

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 暴力法判断是否为质数
    public static boolean isPrimeNaive(int n) {
        if (n <= 1) {
            return false; // 1及以下不是质数
        }
        if (n == 2) {
            return true; // 2是质数
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false; // 存在因数，不是质数
            }
        }
        return true;
    }
}
```

## 2.2 根号n优化版

**原理**

利用质数性质：**若`n`是合数，其最小质因数≤√n。因此只需遍历到`√n`（无需到`n-1`），大幅减少循环次数。**

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 优化版：仅判断到根号n，且跳过偶数
    public static boolean isPrimeOptimized(int n) {
        if (n <= 1) {
            return false;
        }
        if (n == 2) {
            return true; // 唯一偶质数
        }
        if (n % 2 == 0) {
            return false; // 排除其他偶数
        }
        // 仅判断奇数，范围[3, sqrt(n)]
        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 2. 生成指定范围内的所有质数

需高效生成`[2, max_n]`内的所有质数，常用 “筛法”（批量标记合数，剩余为质数）。

## 2.1 埃氏筛法（Eratosthenes Sieve）

**原理**

1. 初始化一个长度为`max_n+1`的布尔数组`is_prime`，默认值为`True`（标记为 “可能是质数”）；
2. 先将`is_prime[0]`和`is_prime[1]`设为`False`（0、1 不是质数）；
3. 从最小质数 2 开始，将其所有倍数（2×2、2×3、…≤max_n）标记为`False`（倍数是合数）；
4. 依次处理下一个未被标记的数（即质数），重复步骤 3，直到遍历完≤√max_n 的所有数；
5. 最终`is_prime`中值为`True`的索引即为质数。

**关键优化**

- 标记倍数时，从`i²`开始（而非`2×i`）：因为`i×2`、`i×3`等已被更小的质数（如 2、3）标记过，避免重复操作。
- 跳过偶数：除 2 外，所有偶数都是合数，可先标记所有偶数，再仅处理奇数（进一步减少计算）。

**复杂度**

- 时间复杂度：O (n log log n)（接近线性，效率极高）；
- 空间复杂度：O (n)（需存储长度为 n+1 的数组）。

```java
import java.util.ArrayList;
import java.util.List;

public class PrimeGenerator {
    // 埃氏筛法生成[2, maxN]范围内的质数
    public static List<Integer> sieveOfEratosthenes(int maxN) {
        List<Integer> primes = new ArrayList<>();
        if (maxN < 2) {
            return primes; // 无质数
        }
        
        boolean[] isPrime = new boolean[maxN + 1];
        // 初始化：默认所有数为质数（除0和1外）
        for (int i = 2; i <= maxN; i++) {
            isPrime[i] = true;
        }
        
        // 标记非质数
        for (int i = 2; i * i <= maxN; i++) {
            if (isPrime[i]) { // 若i是质数，标记其倍数为非质数
                // 从i*i开始标记（优化：更小的倍数已被标记）
                for (int j = i * i; j <= maxN; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        // 收集所有质数
        for (int i = 2; i <= maxN; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }
        return primes;
    }
}
```

## 2.2 欧拉筛法（Euler Sieve，线性筛）

**原理**

埃氏筛法会重复标记某些合数（如 12 会被 2 和 3 分别标记），欧拉筛法通过 “**每个合数仅被其最小质因数标记**”，实现线性时间复杂度 O (n)。  
核心步骤：

1. 维护两个列表：`primes`（存储已找到的质数）、`is_prime`（标记是否为质数）；
2. 遍历每个数`i`（从 2 到 max_n）：
    - 若`i`未被标记（是质数），加入`primes`；
    - 遍历`primes`中的每个质数`p`，标记`i×p`为合数；
    - 关键终止条件：若`i % p == 0`，立即跳出循环（此时`p`是`i`的最小质因数，若继续遍历更大的质数，会导致`i×p`被更大的质数标记，违反 “最小质因数” 原则）。

**复杂度**

- 时间复杂度：O (n)（每个合数仅被标记 1 次）；
- 空间复杂度：O (n)（同埃氏筛）。


```java
import java.util.ArrayList;
import java.util.List;

public class PrimeGenerator {
    // 欧拉筛法生成[2, maxN]范围内的质数（每个合数仅被最小质因数标记）
    public static List<Integer> eulerSieve(int maxN) {
        List<Integer> primes = new ArrayList<>();
        if (maxN < 2) {
            return primes;
        }
        
        boolean[] isPrime = new boolean[maxN + 1];
        for (int i = 2; i <= maxN; i++) {
            isPrime[i] = true;
        }
        
        for (int i = 2; i <= maxN; i++) {
            if (isPrime[i]) {
                primes.add(i); // i是质数，加入列表
            }
            // 标记i与已有质数的乘积为合数
            for (int p : primes) {
                if (i * p > maxN) {
                    break; // 超出范围，终止
                }
                isPrime[i * p] = false;
                if (i % p == 0) {
                    break; // p是i的最小质因数，避免重复标记
                }
            }
        }
        return primes;
    }
}
```