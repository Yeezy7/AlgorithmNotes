# 1. 基础概念

**质数**（又称素数）是指大于 1 的自然数，且除了 1 和它自身外，无法被其他正整数整除的数。

- 最小质数：2（唯一的偶质数）；
- 非质数：1（既不是质数也不是合数）、4（2×2）、6（2×3）等合数。
- 核心性质：若 n 是合数，则 n 必有一个不大于√n 的质因数（为后续算法优化提供依据）。

# 2. 判断单个数字是否为质数

判断一个数`n`是否为质数，需围绕 “排除合数” 设计逻辑，从暴力法逐步优化效率。

## 2.1 暴力枚举法

**原理**

遍历从 `2` 到`n-1`的所有整数，若存在能整除`n`的数，则`n`是合数；否则是质数。

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 暴力法判断是否为质数
    public static boolean isPrimeNaive(int n) {
        if (n <= 1) {
            return false; // 1及以下不是质数
        }
        if (n == 2) {
            return true; // 2是质数
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false; // 存在因数，不是质数
            }
        }
        return true;
    }
}
```

## 2.2 根号n优化版

**原理**

利用质数性质：若`n`是合数，其最小质因数≤√n。因此只需遍历到`√n`（无需到`n-1`），大幅减少循环次数。

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 优化版：仅判断到根号n，且跳过偶数
    public static boolean isPrimeOptimized(int n) {
        if (n <= 1) {
            return false;
        }
        if (n == 2) {
            return true; // 唯一偶质数
        }
        if (n % 2 == 0) {
            return false; // 排除其他偶数
        }
        // 仅判断奇数，范围[3, sqrt(n)]
        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```
