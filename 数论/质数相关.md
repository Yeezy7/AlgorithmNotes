# 1. 基础概念

**质数**（又称素数）是指大于 1 的自然数，且除了 1 和它自身外，无法被其他正整数整除的数。

- 最小质数：2（唯一的偶质数）；
- 非质数：1（既不是质数也不是合数）、4（2×2）、6（2×3）等合数。
- 核心性质：若 n 是合数，则 n 必有一个不大于√n 的质因数（为后续算法优化提供依据）。

# 2. 判断单个数字是否为质数

判断一个数`n`是否为质数，需围绕 “排除合数” 设计逻辑，从暴力法逐步优化效率。

## 2.1 暴力枚举法

**原理**

遍历从 `2` 到`n-1`的所有整数，若存在能整除`n`的数，则`n`是合数；否则是质数。

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 暴力法判断是否为质数
    public static boolean isPrimeNaive(int n) {
        if (n <= 1) {
            return false; // 1及以下不是质数
        }
        if (n == 2) {
            return true; // 2是质数
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false; // 存在因数，不是质数
            }
        }
        return true;
    }
}
```

## 2.2 根号n优化版

**原理**

利用质数性质：**若`n`是合数，其最小质因数≤√n。因此只需遍历到`√n`（无需到`n-1`），大幅减少循环次数。**

**复杂度**

- 时间复杂度：O (n)（最坏情况需遍历 n-2 个数，如 n 为质数时）；
- 空间复杂度：O (1)（无额外空间占用）。

```java
public class PrimeChecker {
    // 优化版：仅判断到根号n，且跳过偶数
    public static boolean isPrimeOptimized(int n) {
        if (n <= 1) {
            return false;
        }
        if (n == 2) {
            return true; // 唯一偶质数
        }
        if (n % 2 == 0) {
            return false; // 排除其他偶数
        }
        // 仅判断奇数，范围[3, sqrt(n)]
        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 2. 生成指定范围内的所有质数

需高效生成`[2, max_n]`内的所有质数，常用 “筛法”（批量标记合数，剩余为质数）。

## 2.1 埃氏筛法（Eratosthenes Sieve）

**原理**

1. 初始化一个长度为`max_n+1`的布尔数组`is_prime`，默认值为`True`（标记为 “可能是质数”）；
2. 先将`is_prime[0]`和`is_prime[1]`设为`False`（0、1 不是质数）；
3. 从最小质数 2 开始，将其所有倍数（2×2、2×3、…≤max_n）标记为`False`（倍数是合数）；
4. 依次处理下一个未被标记的数（即质数），重复步骤 3，直到遍历完≤√max_n 的所有数；
5. 最终`is_prime`中值为`True`的索引即为质数。